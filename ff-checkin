#!/usr/bin/env tclsh

# Tries to check in with the checkin.rvt endpoint and get a list of stuff to do.

package require Tclx
package require http
package require tls
package require json
package require cmdline
package require sha256

package require fa_piaware_config
package require fa_flightfeeder_config
package require fa_flightfeeder_support
package require fa_sysinfo

# check in once an hour normally;
# retry every 5 mins until we succeed;
# except: after running a command, check in immediately (30 seconds)
set ::defaultInterval 900000
set ::errorInterval 300000
set ::shortInterval 30000

set ::checkinTimeout 30000

set ::watchdogCounter 0

set ::keyring "/usr/share/flightfeeder-support/trusted-keyring.gpg"

set ::terminate 0

proc init {argv} {
	::fa_piaware_config::new_combined_config config
	config read_config

	::fa_flightfeeder_config::flightfeeder_state_config stateConfig
	stateConfig read_config

	::fa_flightfeeder_config::flightfeeder_precious_config preciousConfig
	preciousConfig read_config

	set options {
		{dev "run against dev servers"}
		{debug "enable verbose debug output"}
		{autoupgrade.arg "" "run an upgrade attempt for the given packages and exit"}
	}

	set usage ": $::argv0 -help|-dev|-debug"

	if {[catch {array set ::params [::cmdline::getoptions argv $options $usage]} catchResult] == 1} {
		puts stderr $catchResult
		exit 1
	}

	if {[config get flightfeeder-testing]} {
		set ::params(dev) 1
	}

	if {[stateConfig exists flightfeeder-last-checkin]} {
		set ::lastToken [stateConfig get flightfeeder-last-checkin]
	}

	signal trap SIGTERM handle_sigterm
	expr {srand([pid] ^ [clock clicks])}
}

proc handle_sigterm {} {
	logger "Terminating on SIGTERM"
	set ::terminate 1
}

proc logger {msg} {
	puts stderr $msg
}

proc audit_logger {msg} {
	logger $msg
	::fa_flightfeeder_support::write_audit_log $msg
}

# this is a nasty workaround for a bad interaction between
# the http package and the tls package: http writes to the
# socket before the tls handshake has completed, which - if
# the connection stalls at the wrong point - makes tls get
# stuck in a neverending loop of trying to read from the
# underlying socket and getting no data, making ff-checkin
# take 100% CPU (it does keep running though)

# It works by creating a script-level channel that only
# becomes readable/writable _after_ the TLS handshake has
# (asynchronously) completed

oo::class create safetlschan {
	variable sock state watched chanid error hostname

	constructor {args} {
		set host ""
		set port ""

		foreach arg $args {
			switch -glob -- $arg {
				"-*" {
					lappend newargs $arg
				}

				default {
					if {[incr n] == 1} {
						# special hostname formatting:
						#   IP!hostname connects to IP (no DNS lookup)
						#   and expects a CN that matches hostname
						set parts [split $arg "!"]
						if {[llength $parts] == 2} {
							lappend newargs [lindex $parts 0]
							set hostname [lindex $parts 1]
						} else {
							lappend newargs $arg
							set hostname $arg
						}
					} else {
						lappend newargs $arg
					}
				}
			}
		}

		set sock [socket {*}$newargs]
		set watched ""
		set state "init"
		set error ""
	}

	method initialize {ch mode} {
		set chanid $ch
		set state "connecting"
		fileevent $sock writable [list [self object] finish_connect]
		return [list initialize finalize watch read write configure cget cgetall blocking]
	}

	method finalize {ch} {
		if {$state ne "closed"} {
			catch {close $sock}
			set state "closed"
		}
	}

	method watch {ch eventspec} {
		set watched $eventspec
		if {$state eq "connected"} {
			my setup_fileevents $eventspec
		}
	}

	method read {ch count} {
		switch -exact -- $state {
			"error" {
				error $error
			}

			"closed" {
				error "channel is closed"
			}

			"connected" {
				set data [read $sock $count]
				if {$data eq "" && ![eof $sock]} {
					error EAGAIN
				} else {
					return $data
				}
			}

			default {
				error EAGAIN
			}
		}
	}

	method write {ch data} {
		switch -exact -- $state {
			"error" {
				error $error
			}

			"closed" {
				error "channel is closed"
			}

			"connected" {
				puts -nonewline $sock $data
				return [string length $data]
			}

			default {
				error EAGAIN
			}
		}
	}

	method configure {ch option value} {
		fconfigure $sock $option $value
	}

	method cget {ch option} {
		if {$option eq "-error" && $error ne ""} {
			return $error
		} else {
			return [fconfigure $sock $option]
		}
	}

	method cgetall {ch} {
		return [fconfigure $sock]
	}

	method blocking {ch mode} {
		if {$mode} {
			error "blocking mode not supported"
		}
	}

	##
	##

	method finish_connect {} {
		fileevent $sock writable ""

		set sockerror [fconfigure $sock -error]
		if {$sockerror ne ""} {
			my set_error $sockerror
			return
		}

		if {[catch {::tls::import $sock -ssl3 false -ssl2 false -tls1 true -require 1 -cadir "/etc/ssl/certs"} result]} {
			my set_error "::tls::import failed: $result"
			return
		}

		# NB: all translation and buffering is done by tcl as part of the
		# script-level channel infrastructure; we should always deal in
		# unbuffered, untranslated bytes
		fconfigure $sock -blocking 0 -translation binary -buffering none

		set state "handshaking"
		my progress_handshake
	}

	method progress_handshake {} {
		fileevent $sock readable ""
		if {[catch {set done [::tls::handshake $sock]} result]} {
			my set_error $result
			return
		}

		if {!$done} {
			fileevent $sock readable [list [self object] progress_handshake]
			return
		}

		if {[catch {my validate_certificate} result]} {
			my set_error "certificate validation failed: $result"
			return
		}

		set state "connected"
		my setup_fileevents $watched
	}

	method setup_fileevents {what} {
		if {"read" in $what} {
			fileevent $sock readable [list chan postevent $chanid read]
		} else {
			fileevent $sock readable ""
		}

		if {"write" in $what} {
			fileevent $sock writable [list chan postevent $chanid write]
		} else {
			fileevent $sock writable ""
		}
	}

	method set_error {msg} {
		set state "error"
		set error $msg

		if {$watched ne ""} {
			chan postevent $chanid $watched
		}
	}

	# mostly stolen from piaware
	method crack_certificate_fields {string _array} {
		upvar $_array array

		foreach pair [split $string ",/"] {
			lassign [split $pair "="] key value
			set array($key) $value
		}
	}

	method validate_certificate {} {
		array set status [::tls::status $sock]

		# require expected fields
		foreach field "subject issuer notBefore notAfter" {
			if {![info exists status($field)]} {
				error "required certificate field '$field' is missing"
			}
		}

		# make sure the notBefore time has passed
		set notBefore [clock scan $status(notBefore)]
		set now [clock seconds]

		if {$now < $notBefore} {
			error "certificate start time is in the future"
		}

		# make sure the notAfter time has yet to occur
		set notAfter [clock scan $status(notAfter)]
		if {$now > $notAfter} {
			error "certificate expiry is in the past"
		}

		# crack fields in the certificate and require some of them to be present
		my crack_certificate_fields $status(subject) subject
		if {![info exists subject(CN)]} {
			error "certificate subject '$status(subject)' is missing CN"
		}

		set cnParts [split $subject(CN) "."]
		if {[lindex $cnParts 0] eq "*"} {
			# wildcard cert
			set cnTail [lrange $cnParts 1 end]
			if {[llength $cnTail] < 2} {
				set reason "wildcard CN '$subject(CN)' is too general"
				return 0
			}

			set i [expr {[llength $cnTail] - 1}]
			set hostTail [lrange [split $hostname "."] end-$i end]
			if {$cnTail ne $hostTail} {
				error "wildcard certificate CN '$subject(CN)' does not match requested hostname '$hostname'"
			}

			# ok
		} else {
			# exact cert
			if {$subject(CN) ne $hostname} {
				error "certificate CN '$subject(CN)' does not match requested hostname '$hostname'"
			}

			# ok
		}
	}

}

proc make_tls_channel {args} {
	return [chan create {read write} [safetlschan new {*}$args]]
}

proc canonical_post_data {args} {
	array set data $args

	foreach name [lsort [array names data]] {
		# Rivet strips \0 which would break the checksum
		lappend orderedList [string map [list "\0" ""] $name] [string map [list "\0" ""] $data($name)]
	}

	set checksum [::sha2::sha256 -hex -- $orderedList]

	# put the checksum first so that we don't think a truncated POST
	# is actually a no-checksum POST
	return [list "checksum" $checksum {*}$orderedList]
}

proc check_in_with_fa {sysinfo} {
	set candidates ""

	if {$::params(debug)} {
		logger "Starting checking process with sysinfo:"
		foreach {key value} $sysinfo {
			logger [format "  %-40s %s" $key $value]
		}
	}

	if {$::params(dev)} {
		set vhost "[config get flightfeeder-testing-vhost].flightaware.com"
		lappend candidates http-dev-vpn "http://${vhost}/embedded/checkin.rvt" secure fdfa:fafa:3:200::1 3128
		lappend candidates http-dev "http://${vhost}/embedded/checkin.rvt" secure "" ""
	}

	# direct HTTPS
	lappend candidates https-direct https://prod.flightaware.com/embedded/checkin.rvt secure "" ""
	# direct HTTPS, numeric host (in case DNS is hosed)
	# use the magic "!" syntax for hostname that safetlschan interprets so
	# we can connect by IP but validate against a different hostname
	lappend candidates https-numeric https://70.42.6.250!flightaware.com/embedded/checkin.rvt secure "" ""
	# try over the VPN via the FF squid proxy, we consider this secure because of the VPN layer
	# (and trying to get the tcl http lib to do a CONNECT asynchronously is a mess)
	lappend candidates http-vpn http://prod.flightaware.com/embedded/checkin.rvt secure fdfa:fafa:3:200::1 3128

	# if all that fails, move on to insecure methods
	# direct HTTP
	lappend candidates http http://prod.flightaware.com/embedded/checkin.rvt insecure "" ""
	# direct HTTP, numeric host (in case DNS is hosed)
	lappend candidates http-numeric http://70.42.6.250/embedded/checkin.rvt insecure "" ""
	# if the user has a HTTP proxy configured, try that
	# (see above for why we don't try HTTPS here)
	if {[config exists http-proxy-host] && [config exists http-proxy-port]} {
		lappend candidates http-proxy http://prod.flightaware.com/embedded/checkin.rvt insecure [config get http-proxy-host] [config get http-proxy-port]
	}

	::http::register https 443 [list make_tls_channel]
	::http::config -accept "application/json"
	foreach {name url security proxyhost proxyport} $candidates {
		::http::config -proxyhost $proxyhost -proxyport $proxyport
		set postdata [::http::formatQuery {*}[canonical_post_data "via" $name "security" $security {*}$sysinfo]]
		try {
			if {$::params(debug)} {
				logger "Trying to check in using $name ($url)"
			}
			set token [::http::geturl $url -timeout $::checkinTimeout -protocol 1.0 -method POST -query $postdata]
		} on error {result} {
			logger "checkin attempt using $name failed: $result"
			continue
		}

		try {
			if {$::params(debug)} {
				logger "Result status: [::http::status $token]"
				logger "HTTP code: [::http::code $token]"
				logger "HTTP body: [::http::data $token]"
			}

			if {[::http::status $token] ne "ok"} {
				logger "checkin attempt using $name failed: status [::http::status $token]"
				continue
			}

			if {[::http::ncode $token] != 200} {
				logger "checkin attempt using $name failed: server returned [::http::code $token]"
				continue
			}

			set body [::http::data $token]

			# check we can parse it.
			try {
				set d [::json::json2dict $body]
			} on error {result} {
				logger "checkin attempt using $name failed: json parsing of the response failed: $result"
				continue
			}

			return [list $name $security $d]
		} finally {
			catch {::http::cleanup $token}
		}
	}

	return [list "" "" ""]
}

proc fetch_status_keys {path keys _out} {
	upvar $_out out

	set f [open $path "r"]
	try {
		set data [::json::json2dict [read $f]]
	} finally {
		close $f
	}

	set now [clock milliseconds]
	if {[dict get $data time] <= $now && [dict get $data expiry] > $now} {
		# valid file
		foreach key $keys {
			if {[dict exists $data $key]} {
				set out(status-$key) [list [dict get $data $key status] [dict get $data $key message]]
			}
		}
	}
}

# this is pretty defensive as we really don't want this to ever break
proc prepare_system_info {} {
	try {
		set sysinfo(mac) [::fa_sysinfo::mac_address]
	} on error {result} {
		logger "failed to read MAC address: $result"
		lappend sysinfo(checkin-errors) $result
	}

	foreach key {flightfeeder-serial image-type flightfeeder-model} {
		try {
			if {[config exists $key]} {
				set sysinfo($key) [config get $key]
			}
		} on error {result} {
			logger "failed to read config key $key: $result"
			lappend sysinfo(checkin-errors) $result
		}
	}

	try {
		foreach {pkg version} [::fa_flightfeeder_support::flightfeeder_package_versions] {
			set sysinfo(package-$pkg) $version
		}
	} on error {result} {
		logger "failed to fetch flightfeeder packages: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		set broken [::fa_flightfeeder_support::broken_packages]
		if {$broken ne ""} {
			set sysinfo(broken-packages) $broken
		}
	} on error {result} {
		logger "failed to fetch broken packages: $result"
		lappend sysinfo(checkin-errors) $result
	}

	if {[info exists ::lastToken]} {
		set sysinfo(last-token) $::lastToken
	}

	set sysinfo(flightfeeder-commissioned) [config get flightfeeder-commissioned]
	set sysinfo(vpn-cert-loaded) [expr {[file exists "/etc/openvpn/client.key"] && [file exists "/etc/openvpn/client.crt"]}]

	try {
		set sysinfo(vpn-ip) [::fa_flightfeeder_support::vpn_ip]
	} on error {result} {
		logger "failed to get VPN IP: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		set sysinfo(readonly) [::fa_flightfeeder_support::readonly]
	} on error {result} {
		logger "failed to get readonly status: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		fetch_status_keys "/run/beast-splitter/status.json" {piaware radio gps network adept mlat} sysinfo
	} on error {result} {
		logger "failed to fetch status keys from ff-health-monitor: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		set sysinfo(hardware) [::fa_flightfeeder_support::detect_hardware]
	} on error {result} {
		logger "failed to fetch hardware information: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		set sysinfo(cputemp) [::fa_sysinfo::cpu_temperature]
	} on error {result} {
		logger "failed to fetch CPU temperature: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		set sysinfo(uptime) [::fa_sysinfo::uptime]
	} on error {result} {
		logger "failed to fetch uptime: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		set sysinfo(loadavg) [::fa_sysinfo::loadavg]
	} on error {result} {
		logger "failed to fetch loadavg: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		foreach path {/etc/passwd /etc/shadow /etc/ssh/sshd_config /etc/ssh/keys/fa} {
			try {
				lappend sysinfo(hashes) $path [::sha2::sha256 -hex -file $path]
			} on error {result} {
				lappend sysinfo(hashes) $path "error"
			}
		}
	} on error {result} {
		logger "failed to fetch hashes: $result"
		lappend sysinfo(checkin-errors) $result
	}

	try {
		foreach pid [glob -directory /proc -tails -type d {[1-9]*}] {
			try {
				lappend sysinfo(processes) $pid [file readlink "/proc/$pid/exe"]
			} on error {result} {
				# skip
			}
		}
	} on error {result} {
		logger "failed to fetch processes: $result"
		lappend sysinfo(checkin-errors) $result
	}

	set sysinfo(clock) [clock seconds]

	return [array get sysinfo]
}

proc extract_signed_script {signedmessage} {
	set scriptout [file tempfile scriptoutpath "signedscript"]
	close $scriptout

	set gpg [open "|gpg --keyring $::keyring --trust-model always --ignore-time-conflict --decrypt --quiet --batch --yes --status-fd 1 --output $scriptoutpath --max-output 1000000 2>@stderr" "r+"]
	puts -nonewline $gpg $signedmessage
	close $gpg write

	set goodsig 0
	while {[gets $gpg line] >= 0} {
		if {[regexp {^\[GNUPG:\] GOODSIG .*} $line]} {
			set goodsig 1
		}
	}

	try {
		close $gpg
	} trap {CHILDSTATUS} {} {
		lassign $::errorCode errname deadpid status
		logger "gpg exited with return code $status"
		file delete $scriptoutpath
		return ""
	}

	if {!$goodsig} {
		logger "script signature did not verify; script ignored"
		file delete $scriptoutpath
		return ""
	}

	return $scriptoutpath
}

# {
#   "command": "script",
#   "script": "#!/bin/sh ..."
# }
#
# only over HTTPS; we rely on HTTPS authenticating the identity of the server.
# This is the fallback mechanism for most FFs if the management VPN breaks;
# the scripts can be built on the webserver if needed.
proc run_script {script} {
	set scriptout [file tempfile scriptoutpath "script"]
	puts $scriptout $script
	close $scriptout

	try {
		return [run_script_file $scriptoutpath]
	} finally {
		file delete $scriptoutpath
	}
}

# {
#   "command": "signed-script",
#   "signed-script": "-----BEGIN PGP MESSAGE----- ... -----END PGP MESSAGE-----"
# }
#
# Allowed over either HTTP or HTTPS. The contents are a signed unencrypted PGP message
# that has been signed by a trusted key; we validate that signature before allowing
# the script to run. This is how we do general remote management of FFs that are
# behind a firewall that does not allow us to establish a management VPN.
# It will require manual construction of the signed scripts as the webservers won't
# have the private key.
proc run_signed_script {action} {
	try {
		set path [extract_signed_script [dict get $action "signed-script"]]
		if {$path eq ""} {
			# failed to extract, something has been logged
			return 0
		}
		return [run_script_file $path]
	} finally {
		if {[info exists path]} {
			file delete $path
		}
	}
}

proc run_script_file {path} {
	audit_logger "Running script $path.."

	file attributes $path -permissions 0700
	try {
		exec $path </dev/null 2>@stderr
		return 1
	} trap {CHILDSTATUS} {} {
		lassign $::errorCode errname deadpid status
		audit_logger " ... script exited with return code $status"
		return 0
	} trap {CHILDKILLED} {} {
		lassign $::errorCode errname deadpid sig msg
		audit_logger " ... script died with signal $sig ($msg)"
		return 0
	} on error {result} {
		audit_logger " ... error invoking script: $result"
		audit_logger $::errorInfo
		return 0
	}
}

# {
#   "command": "set-serial",
#   "serial": "12345"
# }
proc set_serial {action} {
	if {[::fa_flightfeeder_support::readonly]} {
		logger "Refusing to set serial number on a readonly system"
		return
	}

	set serial [dict get $action "serial"]
	audit_logger "Configuring serial number $serial.."
	preciousConfig read_config
	preciousConfig set_option flightfeeder-serial $serial
	preciousConfig write_config

	# this also invalidates our VPN certificates!
	# we will request new ones on the next checkin
	if {[file exists "/etc/openvpn/client.crt"]} {
		logger "Removing old VPN certificates.."
		file delete "/etc/openvpn/client.crt"
		file delete "/etc/openvpn/client.key"
		exec systemctl --no-block --quiet restart openvpn@ffvpn 2>@stderr
	}

	logger "Regenerating our hostname.."
	exec systemctl --no-block --quiet start generate-ff-hostname 2>@stderr

	logger "Done."
}

# {
#   "command": "load-vpn-certificate",
#   "vpn-certificate": "----BEGIN CERTIFICATE----- .... ----END CERTIFICATE-----",
#   "vpn-key": "----BEGIN PRIVATE KEY----- .... ----END PRIVATE KEY-----",
# }
proc load_vpn_certificate {action} {
	if {[::fa_flightfeeder_support::readonly]} {
		logger "Refusing to load VPN certificates on a readonly system"
		return
	}

	set cert [dict get $action "vpn-certificate"]
	set key [dict get $action "vpn-key"]

	audit_logger "Writing VPN client certificate.."
	set outfile [open "/etc/openvpn/client.crt" "w" 0644]
	puts $outfile $cert
	close $outfile

	audit_logger "Writing VPN client certificate key.."
	set outfile [open "/etc/openvpn/client.key" "w" 0600]
	puts $outfile $key
	close $outfile

	logger "Restarting the management VPN.."
	exec systemctl --no-block --quiet restart openvpn@ffvpn 2>@stderr

	logger "Done."
}

# { "command": "reboot" }
proc do_reboot {action} {
	audit_logger "Reboot requested"
	logger "*** TRIGGERING REBOOT ***"
	exec /sbin/reboot 2>@stderr &
}

# { "command": "readonly" }
proc switch_to_readonly {action} {
	audit_logger "Switching filesystem to readonly"
	exec switch-to-readonly 2>@stderr
}

# { "command": "readwrite" }
proc switch_to_readwrite {action} {
	audit_logger "Switching filesystem to readwrite"
	exec switch-to-readwrite 2>@stderr
}

# {
#   "command": "config",
#   "config" : {
#     "foo": "bar",
#     ...
#   }
# }
proc set_config {action} {
	set settings [dict get $action "config"]

	config read_config

	dict for {key value} $settings {
		# Special handling for bootconfig, flightfeeder-commissioned
		switch -- $key {
			"bootconfig" {
				set_bootconfig $value
			}

			"flightfeeder-serial" - "flightfeeder-commissioned" - "flightfeeder-model" {
				audit_logger "Setting preciousConfig option $key to $value"
				preciousConfig read_config
				preciousConfig set_option $key $value
				preciousConfig write_config
			}

			default {
				audit_logger "Setting config option $key to $value"
				config set_option $key $value
			}
		}
	}

	config write_config
}

proc set_bootconfig {value} {
	if {[::fa_flightfeeder_support::readonly]} {
		logger "Refusing to change the rpi-bootconfig template on a readonly system"
		return
	}

	set template "/usr/share/flightfeeder-support/bootconfig/${value}.txt"
	if {![file exists $template]} {
		logger "Not updating rpi-bootconfig template: missing template $template"
		return
	}

	set defaultsFile "/etc/default/rpi-bootconfig"
	set defaultsEnabled "no"
	set newLines [list]
	if {[file exists $defaultsFile]} {
		try {
			set defaults [open $defaultsFile "r"]
			while {[gets $defaults line] >= 0} {
				if {[regexp {^\s*TEMPLATE=([^#]*)} $line -> defaultsTemplate]} {
					# replace this line
					lappend newLines "TEMPLATE=${template} # set by ff-checkin"
					set defaultsTemplate [string trim $defaultsTemplate]
				} else {
					lappend newLines $line
					regexp {^\s*ENABLED=([^#]*)} $line -> defaultsEnabled
				}
			}
		} on error {result} {
			logger "Not updating rpi-bootconfig template: failed to parse current defaults: $result"
			return
		} finally {
			catch {close $defaults}
		}
	}

	if {$defaultsEnabled ne "yes"} {
		logger "Not updating rpi-bootconfig template: rpi-bootconfig is not enabled"
		return
	}

	if {[info exists defaultsTemplate]} {
		if {$defaultsTemplate eq $template} {
			logger "Not updating rpi-bootconfig template: template did not change"
			return
		}
	} else {
		lappend newLines "TEMPLATE=${template} # set by ff-checkin"
	}

	audit_logger "Setting rpi-bootconfig template to: $template"
	try {
		set newDefaults [open "${defaultsFile}.new" "w"]
		try {
			foreach line $newLines {
				puts $newDefaults $line
			}
			sync $newDefaults
		} finally {
			catch {close $newDefaults}
		}

		file rename -force "${defaultsFile}.new" $defaultsFile
	} on error {result} {
		logger "Failed to change rpi-bootconfig template: $result"
		return
	}

	logger "Regenerating config.txt"
	try {
		exec /usr/lib/piaware-support/rpi-bootconfig update >&@stderr
	} on error {result} {
		logger "Failed to run rpi-bootconfig: $result"
	}
}

proc upgrade_splash {progress} {
	::fa_flightfeeder_support::gui_notify splash "Upgrade in progress.\n\nDo not remove power!\n\n$progress" -expiry 3600 -fg black -bg gold2
}

# {
#   "command": "upgrade",
#   "packages": [....]"    // optional
# }
proc do_upgrade {action} {
	if {[::fa_flightfeeder_support::readonly]} {
		logger "Refusing to upgrade a readonly system"
		return 0
	}

	logger "*** STARTING UPGRADE ***"
	audit_logger "Starting upgrade from FF software version: [::fa_flightfeeder_support::flightfeeder_software_version]"
	if {[dict exists $action "packages"]} {
		set args [list "install" {*}[dict get $action "packages"]]
	} else {
		set args "dist-upgrade"
	}

	set dpkg [list dpkg --configure -a --force-confold]
	set aptget [list apt-get -q -y -o DPkg::Options::=--force-confold]

	try {
		# we reset the alarms to avoid interrupting installs
		# unless they've _really_ got stuck
		alarm 3600.0

		upgrade_splash "Preparing.."

		# we run a dpkg --configure -a and an apt-get install -f first in case a previous upgrade got interrupted
		try {
			logger "Running: $dpkg"
			exec {*}$dpkg </dev/null 2>@stderr
		} on error {result} {
			logger " ... ignoring error: $result"
		}

		try {
			logger "Running: $aptget -f install"
			exec {*}$aptget -f install </dev/null 2>@stderr
		} on error {result} {
			logger " ... ignoring error: $result"
		}

		# update/download can be very slow with a bad network
		# give it an hour..
		alarm 3600.0
		upgrade_splash "Downloading metadata.."
		logger "Running: $aptget update"
		exec {*}$aptget update </dev/null |& tee /tmp/ff-checkin.out >@stdout 2>@stderr

		# check for a failure to download
		# sadly you can't seem to make apt treat this as a hard error
		set f [open "/tmp/ff-checkin.out" "r"]
		try {
			while {[gets $f line] >= 0} {
				if {[string match {*Some index files failed to download*} $line]} {
					audit_logger " ... upgrade failed to download metadata: $line"
					return 0
				}
			}
		} finally {
			catch {close $f}
		}

		upgrade_splash "Downloading updates.."
		logger "Running: $aptget --download-only $args"
		exec {*}$aptget --download-only {*}$args </dev/null >@stdout 2>@stderr

		# finally, do the upgrade
		alarm 3600.0
		upgrade_splash "Installing updates.."
		logger "Running: $aptget $args"
		exec {*}$aptget {*}$args </dev/null >@stdout 2>@stderr

		# .. and clean up
		upgrade_splash "Cleaning up.."
		logger "Running: $aptget autoclean"
		exec {*}$aptget autoclean </dev/null >@stdout 2>@stderr

		audit_logger "Completed upgrade to FF software version: [::fa_flightfeeder_support::flightfeeder_software_version]"
		logger "*** UPGRADE COMPLETE ***"

		return 1
	} trap {CHILDSTATUS} {} {
		lassign $::errorCode errname deadpid status
		audit_logger " ... upgrade exited with return code $status"
		return 0
	} trap {CHILDKILLED} {} {
		lassign $::errorCode errname deadpid sig msg
		audit_logger " ... upgrade died with signal $sig ($msg)"
		return 0
	} on error {result} {
		audit_logger " ... error invoking upgrade: $result"
		audit_logger $::errorInfo
		return 0
	} finally {
		::fa_flightfeeder_support::gui_notify clear
	}
}

proc set_model {model} {
	if {[::fa_flightfeeder_support::readonly]} {
		logger "Refusing to set model number on a readonly system"
		return
	}

	audit_logger "Configuring FlightFeeder model to $model.."
	preciousConfig read_config
	preciousConfig set_option flightfeeder-model $model
	preciousConfig write_config
}

proc setup_uat {action} {
        if {[::fa_flightfeeder_support::readonly]} {
                logger "Refusing to set flightfeeder to UAT mode on a readonly system"
                return
        }

	logger "Setting FlightFeeder to UAT mode"

	set_model "H9T"

	config read_config

	audit_logger "Configuring receiver-type to none..."
	config set_option receiver-type none

	audit_logger "Configuring uat-receiver-type to sdr..."
	config set_option uat-receiver-type sdr
	config write_config

	logger "Done."
}

proc handle_checkin_result {name security data} {
	if {$name eq ""} {
		logger "Checking in via all possible methods failed"
		return $::errorInterval
	}

	# we checked in ok.
	logger "Checked in using $name ($security)"
	set ::watchdogCounter 0

	# checkin response looks like this:
	#
	# {
	#   "token": "opaque token value",  // optional
	#   "commands": [ ..... ]
	# }
	#
	# if token is present, remember it and pass it back as last-token on the
	# next checkin (this is so the server side can know that it made it to us)
	#
	# run the stuff in the commands array in order

	if {[dict exists $data "token"]} {
		# record that we got it
		set ::lastToken [dict get $data "token"]

		try {
			stateConfig read_config
			stateConfig set_option flightfeeder-last-checkin $::lastToken
			stateConfig write_config
		} on error {result} {
			logger "failed to update stateConfig: $result"
			# but continue!
		}
	}

	if {[dict exists $data "interval"]} {
		set interval [dict get $data "interval"]
	} elseif {![config get flightfeeder-commissioned]} {
		set interval $::shortInterval
	} else {
		set interval $::defaultInterval
	}

	foreach action [dict get $data "commands"] {
		set interval $::shortInterval
		set command [dict get $action "command"]

		# if we checked in over HTTP, limit what is allowable
		if {$security ne "secure" && $command ni {signed-script upgrade readonly readwrite reboot}} {
			logger "command '$command' is only permitted over secure transports, ignored"
			continue
		}

		logger "preparing to run command '$command'.."

		try {
			switch -exact $command {
				"set-serial" {
					set_serial $action
				}

				"load-vpn-certificate" {
					load_vpn_certificate $action
				}

				"reboot" {}

				"script" {
					if {![run_script $action]} {
						break
					}
				}

				"signed-script" {
					if {![run_signed_script $action]} {
						break
					}
				}

				"upgrade" {}

				"readonly" {
					switch_to_readonly $action
				}

				"readwrite" {
					switch_to_readwrite $action
				}

				"config" {
					set_config $action
				}

				"setup-uat" {
					setup_uat $action
				}

				default {
					logger "command '$command' is not understood, ignored"
				}
			}
		} on error {result} {
			logger "command '$command' failed with a tcl error"
			logger $::errorInfo
			break
		}
	}

	return $interval
}

proc periodically_checkin {} {
	try {
		set interval [try_to_check_in]
		set interval [expr {int($interval * (0.8 + 0.4 * rand()))}]
		logger "Next checkin in [expr {round($interval/1000)}] seconds"
		after $interval periodically_checkin
	} on error {result} {
		after 30000 periodically_checkin
		logger "Triggered safety net due to: $result"
	}
}

proc try_to_check_in {} {
	try {
		config read_config
		set sysinfo [prepare_system_info]

		# extra paranoia so we don't wedge
		alarm [expr {$::checkinTimeout * 10 / 1000.0}]
		try {
			lassign [check_in_with_fa $sysinfo] name security result
			# give it an hour to do stuff
			alarm 3600.0
			set interval [handle_checkin_result $name $security $result]
			return $interval
		} finally {
			alarm 0.0
		}
	} on error {result} {
		logger "Checkin failed with a tcl error"
		logger $::errorInfo
		return $::defaultInterval
	}
}

# Once a minute we run this;
# if we run for 36 hours without a successful checkin happening,
# reboot the system.
#
# nb: we do this as a series of checks with a counter rather than one
# long "after" or using system time to avoid jumps in system time from
# unexpectedly triggering a reboot
proc check_watchdog {} {
	after 60000 check_watchdog

	incr ::watchdogCounter
	if {$::watchdogCounter >= (60 * 36)} {
		logger "*** WATCHDOG FIRED ***"
		audit_logger "No successful checkins for ages. Rebooting the system."
		# decrement the counter a little so we try this once an hour
		incr ::watchdogCounter -60
		exec /sbin/reboot 2>@stderr &
	}
}

proc main {argv} {
	init $argv

	if {$::params(autoupgrade) ne ""} {
		logger "Running upgrade for packages: $::params(autoupgrade)"
		set action [dict create \
						"command" "upgrade" \
						"packages" $::params(autoupgrade)]
		try {
			set success [do_upgrade $action]
		} on error {result} {
			logger "caught error during upgrade: $::errorInfo"
			set success 0
		}

		if {$success} {
			exit 0
		} else {
			exit 1
		}
	}

	if {$::params(debug)} {
		periodically_checkin
	} else {
		# delay the first checkin a little to let the network settle
		# we do a double-after because the clock is likely to change
		# when the network comes up, and tcl is using wallclock not
		# a monotonic clock to measure intervals
		after 15000 [list after 15000 periodically_checkin]
		after 60000 check_watchdog
	}

	while {!$::terminate} {
		vwait ::terminate
	}
}

if {!$tcl_interactive} {
	main $argv
}
